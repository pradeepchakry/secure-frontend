{"ast":null,"code":"/**\n * Copyright Schrodinger, LLC\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule PrefixIntervalTree\n * \n * @typechecks\n */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _invariant = _interopRequireDefault(require('./invariant'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nvar parent = function parent(node) {\n  return Math.floor(node / 2);\n};\n\nvar Int32Array = global.Int32Array || function (size) {\n  var xs = [];\n\n  for (var i = size - 1; i >= 0; --i) {\n    xs[i] = 0;\n  }\n\n  return xs;\n};\n/**\n * Computes the next power of 2 after or equal to x.\n */\n\n\nfunction ceilLog2(x) {\n  var y = 1;\n\n  while (y < x) {\n    y *= 2;\n  }\n\n  return y;\n}\n/**\n * A prefix interval tree stores an numeric array and the partial sums of that\n * array. It is optimized for updating the values of the array without\n * recomputing all of the partial sums.\n *\n *   - O(ln n) update\n *   - O(1) lookup\n *   - O(ln n) compute a partial sum\n *   - O(n) space\n *\n * Note that the sequence of partial sums is one longer than the array, so that\n * the first partial sum is always 0, and the last partial sum is the sum of the\n * entire array.\n */\n\n\nvar PrefixIntervalTree = /*#__PURE__*/function () {\n  function PrefixIntervalTree(xs) {\n    _classCallCheck(this, PrefixIntervalTree);\n    /**\n     * Number of elements in the array\n     *\n     * @type {number}\n     * @private\n     */\n\n\n    this._size = xs.length;\n    /**\n     * Half the size of the heap. It is also the number of non-leaf nodes, and the\n     * index of the first element in the heap. Always a power of 2.\n     *\n     * @type {number}\n     * @private\n     */\n\n    this._half = ceilLog2(this._size);\n    /**\n     * Binary heap\n     *\n     * @type {!Array.<number>}\n     * @const\n     * @private\n     */\n\n    this._heap = new Int32Array(2 * this._half);\n    var i;\n\n    for (i = 0; i < this._size; ++i) {\n      this._heap[this._half + i] = xs[i];\n    }\n\n    for (i = this._half - 1; i > 0; --i) {\n      this._heap[i] = this._heap[2 * i] + this._heap[2 * i + 1];\n    }\n  }\n\n  _createClass(PrefixIntervalTree, [{\n    key: \"set\",\n    value: function set(index, value) {\n      (0, _invariant[\"default\"])(0 <= index && index < this._size, 'Index out of range %s', index);\n      var node = this._half + index;\n      this._heap[node] = value;\n      node = parent(node);\n\n      for (; node !== 0; node = parent(node)) {\n        this._heap[node] = this._heap[2 * node] + this._heap[2 * node + 1];\n      }\n    }\n  }, {\n    key: \"get\",\n    value: function get(index) {\n      (0, _invariant[\"default\"])(0 <= index && index < this._size, 'Index out of range %s', index);\n      var node = this._half + index;\n      return this._heap[node];\n    }\n  }, {\n    key: \"getSize\",\n    value: function getSize() {\n      return this._size;\n    }\n    /**\n     * Returns the sum get(0) + get(1) + ... + get(end - 1).\n     */\n\n  }, {\n    key: \"sumUntil\",\n    value: function sumUntil(end) {\n      (0, _invariant[\"default\"])(0 <= end && end < this._size + 1, 'Index out of range %s', end);\n\n      if (end === 0) {\n        return 0;\n      }\n\n      var node = this._half + end - 1;\n      var sum = this._heap[node];\n\n      for (; node !== 1; node = parent(node)) {\n        if (node % 2 === 1) {\n          sum += this._heap[node - 1];\n        }\n      }\n\n      return sum;\n    }\n    /**\n     * Returns the sum get(0) + get(1) + ... + get(inclusiveEnd).\n     */\n\n  }, {\n    key: \"sumTo\",\n    value: function sumTo(inclusiveEnd) {\n      (0, _invariant[\"default\"])(0 <= inclusiveEnd && inclusiveEnd < this._size, 'Index out of range %s', inclusiveEnd);\n      return this.sumUntil(inclusiveEnd + 1);\n    }\n    /**\n     * Returns the sum get(begin) + get(begin + 1) + ... + get(end - 1).\n     */\n\n  }, {\n    key: \"sum\",\n    value: function sum(begin, end) {\n      (0, _invariant[\"default\"])(begin <= end, 'Begin must precede end');\n      return this.sumUntil(end) - this.sumUntil(begin);\n    }\n    /**\n     * Returns the smallest i such that 0 <= i <= size and sumUntil(i) <= t, or\n     * -1 if no such i exists.\n     */\n\n  }, {\n    key: \"greatestLowerBound\",\n    value: function greatestLowerBound(t) {\n      if (t < 0) {\n        return -1;\n      }\n\n      var node = 1;\n\n      if (this._heap[node] <= t) {\n        return this._size;\n      }\n\n      while (node < this._half) {\n        var leftSum = this._heap[2 * node];\n\n        if (t < leftSum) {\n          node = 2 * node;\n        } else {\n          node = 2 * node + 1;\n          t -= leftSum;\n        }\n      }\n\n      return node - this._half;\n    }\n    /**\n     * Returns the smallest i such that 0 <= i <= size and sumUntil(i) < t, or\n     * -1 if no such i exists.\n     */\n\n  }, {\n    key: \"greatestStrictLowerBound\",\n    value: function greatestStrictLowerBound(t) {\n      if (t <= 0) {\n        return -1;\n      }\n\n      var node = 1;\n\n      if (this._heap[node] < t) {\n        return this._size;\n      }\n\n      while (node < this._half) {\n        var leftSum = this._heap[2 * node];\n\n        if (t <= leftSum) {\n          node = 2 * node;\n        } else {\n          node = 2 * node + 1;\n          t -= leftSum;\n        }\n      }\n\n      return node - this._half;\n    }\n    /**\n     * Returns the smallest i such that 0 <= i <= size and t <= sumUntil(i), or\n     * size + 1 if no such i exists.\n     */\n\n  }, {\n    key: \"leastUpperBound\",\n    value: function leastUpperBound(t) {\n      return this.greatestStrictLowerBound(t) + 1;\n    }\n    /**\n     * Returns the smallest i such that 0 <= i <= size and t < sumUntil(i), or\n     * size + 1 if no such i exists.\n     */\n\n  }, {\n    key: \"leastStrictUpperBound\",\n    value: function leastStrictUpperBound(t) {\n      return this.greatestLowerBound(t) + 1;\n    }\n  }], [{\n    key: \"uniform\",\n    value: function uniform(size, initialValue) {\n      var xs = [];\n\n      for (var i = size - 1; i >= 0; --i) {\n        xs[i] = initialValue;\n      }\n\n      return new PrefixIntervalTree(xs);\n    }\n  }, {\n    key: \"empty\",\n    value: function empty(size) {\n      return PrefixIntervalTree.uniform(size, 0);\n    }\n  }]);\n\n  return PrefixIntervalTree;\n}();\n\nvar _default = PrefixIntervalTree;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["/home/discovery/Documents/secure-frontend/node_modules/fixed-data-table-2/internal/PrefixIntervalTree.js"],"names":["Object","defineProperty","exports","value","_invariant","_interopRequireDefault","require","obj","__esModule","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","_createClass","protoProps","staticProps","prototype","parent","node","Math","floor","Int32Array","global","size","xs","ceilLog2","x","y","PrefixIntervalTree","_size","_half","_heap","set","index","get","getSize","sumUntil","end","sum","sumTo","inclusiveEnd","begin","greatestLowerBound","t","leftSum","greatestStrictLowerBound","leastUpperBound","leastStrictUpperBound","uniform","initialValue","empty","_default"],"mappings":"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","sourcesContent":["/**\n * Copyright Schrodinger, LLC\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule PrefixIntervalTree\n * \n * @typechecks\n */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _invariant = _interopRequireDefault(require('./invariant'));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar parent = function parent(node) {\n  return Math.floor(node / 2);\n};\n\nvar Int32Array = global.Int32Array || function (size) {\n  var xs = [];\n\n  for (var i = size - 1; i >= 0; --i) {\n    xs[i] = 0;\n  }\n\n  return xs;\n};\n/**\n * Computes the next power of 2 after or equal to x.\n */\n\n\nfunction ceilLog2(x) {\n  var y = 1;\n\n  while (y < x) {\n    y *= 2;\n  }\n\n  return y;\n}\n/**\n * A prefix interval tree stores an numeric array and the partial sums of that\n * array. It is optimized for updating the values of the array without\n * recomputing all of the partial sums.\n *\n *   - O(ln n) update\n *   - O(1) lookup\n *   - O(ln n) compute a partial sum\n *   - O(n) space\n *\n * Note that the sequence of partial sums is one longer than the array, so that\n * the first partial sum is always 0, and the last partial sum is the sum of the\n * entire array.\n */\n\n\nvar PrefixIntervalTree = /*#__PURE__*/function () {\n  function PrefixIntervalTree(xs) {\n    _classCallCheck(this, PrefixIntervalTree);\n\n    /**\n     * Number of elements in the array\n     *\n     * @type {number}\n     * @private\n     */\n    this._size = xs.length;\n    /**\n     * Half the size of the heap. It is also the number of non-leaf nodes, and the\n     * index of the first element in the heap. Always a power of 2.\n     *\n     * @type {number}\n     * @private\n     */\n\n    this._half = ceilLog2(this._size);\n    /**\n     * Binary heap\n     *\n     * @type {!Array.<number>}\n     * @const\n     * @private\n     */\n\n    this._heap = new Int32Array(2 * this._half);\n    var i;\n\n    for (i = 0; i < this._size; ++i) {\n      this._heap[this._half + i] = xs[i];\n    }\n\n    for (i = this._half - 1; i > 0; --i) {\n      this._heap[i] = this._heap[2 * i] + this._heap[2 * i + 1];\n    }\n  }\n\n  _createClass(PrefixIntervalTree, [{\n    key: \"set\",\n    value: function set(index, value) {\n      (0, _invariant[\"default\"])(0 <= index && index < this._size, 'Index out of range %s', index);\n      var node = this._half + index;\n      this._heap[node] = value;\n      node = parent(node);\n\n      for (; node !== 0; node = parent(node)) {\n        this._heap[node] = this._heap[2 * node] + this._heap[2 * node + 1];\n      }\n    }\n  }, {\n    key: \"get\",\n    value: function get(index) {\n      (0, _invariant[\"default\"])(0 <= index && index < this._size, 'Index out of range %s', index);\n      var node = this._half + index;\n      return this._heap[node];\n    }\n  }, {\n    key: \"getSize\",\n    value: function getSize() {\n      return this._size;\n    }\n    /**\n     * Returns the sum get(0) + get(1) + ... + get(end - 1).\n     */\n\n  }, {\n    key: \"sumUntil\",\n    value: function sumUntil(end) {\n      (0, _invariant[\"default\"])(0 <= end && end < this._size + 1, 'Index out of range %s', end);\n\n      if (end === 0) {\n        return 0;\n      }\n\n      var node = this._half + end - 1;\n      var sum = this._heap[node];\n\n      for (; node !== 1; node = parent(node)) {\n        if (node % 2 === 1) {\n          sum += this._heap[node - 1];\n        }\n      }\n\n      return sum;\n    }\n    /**\n     * Returns the sum get(0) + get(1) + ... + get(inclusiveEnd).\n     */\n\n  }, {\n    key: \"sumTo\",\n    value: function sumTo(inclusiveEnd) {\n      (0, _invariant[\"default\"])(0 <= inclusiveEnd && inclusiveEnd < this._size, 'Index out of range %s', inclusiveEnd);\n      return this.sumUntil(inclusiveEnd + 1);\n    }\n    /**\n     * Returns the sum get(begin) + get(begin + 1) + ... + get(end - 1).\n     */\n\n  }, {\n    key: \"sum\",\n    value: function sum(begin, end) {\n      (0, _invariant[\"default\"])(begin <= end, 'Begin must precede end');\n      return this.sumUntil(end) - this.sumUntil(begin);\n    }\n    /**\n     * Returns the smallest i such that 0 <= i <= size and sumUntil(i) <= t, or\n     * -1 if no such i exists.\n     */\n\n  }, {\n    key: \"greatestLowerBound\",\n    value: function greatestLowerBound(t) {\n      if (t < 0) {\n        return -1;\n      }\n\n      var node = 1;\n\n      if (this._heap[node] <= t) {\n        return this._size;\n      }\n\n      while (node < this._half) {\n        var leftSum = this._heap[2 * node];\n\n        if (t < leftSum) {\n          node = 2 * node;\n        } else {\n          node = 2 * node + 1;\n          t -= leftSum;\n        }\n      }\n\n      return node - this._half;\n    }\n    /**\n     * Returns the smallest i such that 0 <= i <= size and sumUntil(i) < t, or\n     * -1 if no such i exists.\n     */\n\n  }, {\n    key: \"greatestStrictLowerBound\",\n    value: function greatestStrictLowerBound(t) {\n      if (t <= 0) {\n        return -1;\n      }\n\n      var node = 1;\n\n      if (this._heap[node] < t) {\n        return this._size;\n      }\n\n      while (node < this._half) {\n        var leftSum = this._heap[2 * node];\n\n        if (t <= leftSum) {\n          node = 2 * node;\n        } else {\n          node = 2 * node + 1;\n          t -= leftSum;\n        }\n      }\n\n      return node - this._half;\n    }\n    /**\n     * Returns the smallest i such that 0 <= i <= size and t <= sumUntil(i), or\n     * size + 1 if no such i exists.\n     */\n\n  }, {\n    key: \"leastUpperBound\",\n    value: function leastUpperBound(t) {\n      return this.greatestStrictLowerBound(t) + 1;\n    }\n    /**\n     * Returns the smallest i such that 0 <= i <= size and t < sumUntil(i), or\n     * size + 1 if no such i exists.\n     */\n\n  }, {\n    key: \"leastStrictUpperBound\",\n    value: function leastStrictUpperBound(t) {\n      return this.greatestLowerBound(t) + 1;\n    }\n  }], [{\n    key: \"uniform\",\n    value: function uniform(size, initialValue) {\n      var xs = [];\n\n      for (var i = size - 1; i >= 0; --i) {\n        xs[i] = initialValue;\n      }\n\n      return new PrefixIntervalTree(xs);\n    }\n  }, {\n    key: \"empty\",\n    value: function empty(size) {\n      return PrefixIntervalTree.uniform(size, 0);\n    }\n  }]);\n\n  return PrefixIntervalTree;\n}();\n\nvar _default = PrefixIntervalTree;\nexports[\"default\"] = _default;"]},"metadata":{},"sourceType":"script"}