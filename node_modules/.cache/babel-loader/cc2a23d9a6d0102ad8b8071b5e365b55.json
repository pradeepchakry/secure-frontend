{"ast":null,"code":"/**\n * Copyright Schrodinger, LLC\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule scrollAnchor\n */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getScrollAnchor = getScrollAnchor;\nexports.scrollTo = scrollTo;\n\nvar _clamp = _interopRequireDefault(require('./clamp'));\n\nvar _updateRowHeight = _interopRequireDefault(require('./updateRowHeight'));\n\nvar _scrollbarsVisible = _interopRequireDefault(require('./scrollbarsVisible'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n/**\n * Get the anchor for scrolling.\n * This will either be the first row's index and an offset, or the last row's index.\n * We also pass a flag indicating if the anchor has changed from the state\n *\n * @param {!Object} state\n * @param {!Object} newProps\n * @param {!Object} oldProps\n * @return {{\n *   firstIndex: number,\n *   firstOffset: number,\n *   lastIndex: number,\n *   changed: boolean,\n * }}\n */\n\n\nfunction getScrollAnchor(state, newProps, oldProps) {\n  if (newProps.scrollToRow !== undefined && newProps.scrollToRow !== null && (!oldProps || newProps.scrollToRow !== oldProps.scrollToRow)) {\n    return scrollToRow(state, newProps.scrollToRow);\n  }\n\n  if (newProps.scrollTop !== undefined && newProps.scrollTop !== null && (!oldProps || newProps.scrollTop !== oldProps.scrollTop)) {\n    return scrollTo(state, newProps.scrollTop);\n  }\n\n  return {\n    firstIndex: state.firstRowIndex,\n    firstOffset: state.firstRowOffset,\n    lastIndex: undefined,\n    changed: false\n  };\n}\n/**\n * Scroll to a specific position in the grid\n *\n * @param {!Object} state\n * @param {number} scrollY\n * @return {{\n *   firstIndex: number,\n *   firstOffset: number,\n *   lastIndex: number,\n *   changed: boolean,\n * }}\n */\n\n\nfunction scrollTo(state, scrollY) {\n  var _scrollbarsVisibleSel = (0, _scrollbarsVisible[\"default\"])(state),\n      availableHeight = _scrollbarsVisibleSel.availableHeight;\n\n  var rowOffsetIntervalTree = state.rowOffsetIntervalTree,\n      rowSettings = state.rowSettings,\n      scrollContentHeight = state.scrollContentHeight;\n  var rowsCount = rowSettings.rowsCount;\n\n  if (rowsCount === 0) {\n    return {\n      firstIndex: 0,\n      firstOffset: 0,\n      lastIndex: undefined,\n      changed: state.firstRowIndex !== 0 || state.firstRowOffset !== 0\n    };\n  }\n\n  var firstIndex = 0;\n  var firstOffset = 0;\n  var lastIndex = undefined;\n\n  if (scrollY <= 0) {// Use defaults (from above) to scroll to first row\n  } else if (scrollY >= scrollContentHeight - availableHeight) {\n    // Scroll to the last row\n    firstIndex = undefined;\n    lastIndex = rowsCount - 1;\n  } else {\n    // Mark the row which will appear first in the viewport\n    // We use this as our \"marker\" when scrolling even if updating rowOffsets\n    // leads to it not being different from the scrollY specified\n    var newRowIdx = rowOffsetIntervalTree.greatestLowerBound(scrollY);\n    firstIndex = (0, _clamp[\"default\"])(newRowIdx, 0, Math.max(rowsCount - 1, 0)); // Record how far into the first row we should scroll\n    // firstOffset is a negative value representing how much larger scrollY is\n    // than the scroll position of the first row in the viewport\n\n    var firstRowPosition = rowOffsetIntervalTree.sumUntil(firstIndex);\n    firstOffset = firstRowPosition - scrollY;\n  }\n\n  return {\n    firstIndex: firstIndex,\n    firstOffset: firstOffset,\n    lastIndex: lastIndex,\n    // NOTE (jordan) This changed heuristic may give false positives,\n    // but that's fine since it's used as a filter to computeRenderedRows\n    changed: true\n  };\n}\n/**\n * Scroll a specified row into the viewport\n * If the row is before the viewport, it will become the first row in the viewport\n * If the row is after the viewport, it will become the last row in the viewport\n * If the row is in the viewport, do nothing\n *\n * @param {!Object} state\n * @param {number} rowIndex\n * @return {{\n *   firstIndex: number,\n *   firstOffset: number,\n *   lastIndex: number,\n *   changed: boolean,\n * }}\n * @private\n */\n\n\nfunction scrollToRow(state, rowIndex) {\n  var _scrollbarsVisibleSel2 = (0, _scrollbarsVisible[\"default\"])(state),\n      availableHeight = _scrollbarsVisibleSel2.availableHeight;\n\n  var rowOffsetIntervalTree = state.rowOffsetIntervalTree,\n      rowSettings = state.rowSettings,\n      storedHeights = state.storedHeights,\n      scrollY = state.scrollY;\n  var rowsCount = rowSettings.rowsCount;\n\n  if (rowsCount === 0) {\n    return {\n      firstIndex: 0,\n      firstOffset: 0,\n      lastIndex: undefined,\n      changed: state.firstRowIndex !== 0 || state.firstRowOffset !== 0\n    };\n  }\n\n  rowIndex = (0, _clamp[\"default\"])(rowIndex, 0, Math.max(rowsCount - 1, 0));\n  (0, _updateRowHeight[\"default\"])(state, rowIndex);\n  var rowBegin = rowOffsetIntervalTree.sumUntil(rowIndex);\n  var rowEnd = rowBegin + storedHeights[rowIndex];\n  var firstIndex = rowIndex;\n  var lastIndex = undefined;\n\n  if (rowBegin < scrollY) {// If before the viewport, set as the first row in the viewport\n    // Uses defaults (from above)\n  } else if (scrollY + availableHeight < rowEnd) {\n    // If after the viewport, set as the last row in the viewport\n    firstIndex = undefined;\n    lastIndex = rowIndex;\n  } else {\n    // If already in the viewport, do nothing.\n    return {\n      firstIndex: state.firstRowIndex,\n      firstOffset: state.firstRowOffset,\n      lastIndex: undefined,\n      changed: false\n    };\n  }\n\n  return {\n    firstIndex: firstIndex,\n    firstOffset: 0,\n    lastIndex: lastIndex,\n    changed: true\n  };\n}","map":{"version":3,"sources":["/home/discovery/Documents/secure-frontend/node_modules/fixed-data-table-2/internal/scrollAnchor.js"],"names":["Object","defineProperty","exports","value","getScrollAnchor","scrollTo","_clamp","_interopRequireDefault","require","_updateRowHeight","_scrollbarsVisible","obj","__esModule","state","newProps","oldProps","scrollToRow","undefined","scrollTop","firstIndex","firstRowIndex","firstOffset","firstRowOffset","lastIndex","changed","scrollY","_scrollbarsVisibleSel","availableHeight","rowOffsetIntervalTree","rowSettings","scrollContentHeight","rowsCount","newRowIdx","greatestLowerBound","Math","max","firstRowPosition","sumUntil","rowIndex","_scrollbarsVisibleSel2","storedHeights","rowBegin","rowEnd"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,eAAR,GAA0BA,eAA1B;AACAF,OAAO,CAACG,QAAR,GAAmBA,QAAnB;;AAEA,IAAIC,MAAM,GAAGC,sBAAsB,CAACC,OAAO,CAAC,SAAD,CAAR,CAAnC;;AAEA,IAAIC,gBAAgB,GAAGF,sBAAsB,CAACC,OAAO,CAAC,mBAAD,CAAR,CAA7C;;AAEA,IAAIE,kBAAkB,GAAGH,sBAAsB,CAACC,OAAO,CAAC,qBAAD,CAAR,CAA/C;;AAEA,SAASD,sBAAT,CAAgCI,GAAhC,EAAqC;AAAE,SAAOA,GAAG,IAAIA,GAAG,CAACC,UAAX,GAAwBD,GAAxB,GAA8B;AAAE,eAAWA;AAAb,GAArC;AAA0D;AAEjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASP,eAAT,CAAyBS,KAAzB,EAAgCC,QAAhC,EAA0CC,QAA1C,EAAoD;AAClD,MAAID,QAAQ,CAACE,WAAT,KAAyBC,SAAzB,IAAsCH,QAAQ,CAACE,WAAT,KAAyB,IAA/D,KAAwE,CAACD,QAAD,IAAaD,QAAQ,CAACE,WAAT,KAAyBD,QAAQ,CAACC,WAAvH,CAAJ,EAAyI;AACvI,WAAOA,WAAW,CAACH,KAAD,EAAQC,QAAQ,CAACE,WAAjB,CAAlB;AACD;;AAED,MAAIF,QAAQ,CAACI,SAAT,KAAuBD,SAAvB,IAAoCH,QAAQ,CAACI,SAAT,KAAuB,IAA3D,KAAoE,CAACH,QAAD,IAAaD,QAAQ,CAACI,SAAT,KAAuBH,QAAQ,CAACG,SAAjH,CAAJ,EAAiI;AAC/H,WAAOb,QAAQ,CAACQ,KAAD,EAAQC,QAAQ,CAACI,SAAjB,CAAf;AACD;;AAED,SAAO;AACLC,IAAAA,UAAU,EAAEN,KAAK,CAACO,aADb;AAELC,IAAAA,WAAW,EAAER,KAAK,CAACS,cAFd;AAGLC,IAAAA,SAAS,EAAEN,SAHN;AAILO,IAAAA,OAAO,EAAE;AAJJ,GAAP;AAMD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASnB,QAAT,CAAkBQ,KAAlB,EAAyBY,OAAzB,EAAkC;AAChC,MAAIC,qBAAqB,GAAG,CAAC,GAAGhB,kBAAkB,CAAC,SAAD,CAAtB,EAAmCG,KAAnC,CAA5B;AAAA,MACIc,eAAe,GAAGD,qBAAqB,CAACC,eAD5C;;AAGA,MAAIC,qBAAqB,GAAGf,KAAK,CAACe,qBAAlC;AAAA,MACIC,WAAW,GAAGhB,KAAK,CAACgB,WADxB;AAAA,MAEIC,mBAAmB,GAAGjB,KAAK,CAACiB,mBAFhC;AAGA,MAAIC,SAAS,GAAGF,WAAW,CAACE,SAA5B;;AAEA,MAAIA,SAAS,KAAK,CAAlB,EAAqB;AACnB,WAAO;AACLZ,MAAAA,UAAU,EAAE,CADP;AAELE,MAAAA,WAAW,EAAE,CAFR;AAGLE,MAAAA,SAAS,EAAEN,SAHN;AAILO,MAAAA,OAAO,EAAEX,KAAK,CAACO,aAAN,KAAwB,CAAxB,IAA6BP,KAAK,CAACS,cAAN,KAAyB;AAJ1D,KAAP;AAMD;;AAED,MAAIH,UAAU,GAAG,CAAjB;AACA,MAAIE,WAAW,GAAG,CAAlB;AACA,MAAIE,SAAS,GAAGN,SAAhB;;AAEA,MAAIQ,OAAO,IAAI,CAAf,EAAkB,CAAC;AAClB,GADD,MACO,IAAIA,OAAO,IAAIK,mBAAmB,GAAGH,eAArC,EAAsD;AAC3D;AACAR,IAAAA,UAAU,GAAGF,SAAb;AACAM,IAAAA,SAAS,GAAGQ,SAAS,GAAG,CAAxB;AACD,GAJM,MAIA;AACL;AACA;AACA;AACA,QAAIC,SAAS,GAAGJ,qBAAqB,CAACK,kBAAtB,CAAyCR,OAAzC,CAAhB;AACAN,IAAAA,UAAU,GAAG,CAAC,GAAGb,MAAM,CAAC,SAAD,CAAV,EAAuB0B,SAAvB,EAAkC,CAAlC,EAAqCE,IAAI,CAACC,GAAL,CAASJ,SAAS,GAAG,CAArB,EAAwB,CAAxB,CAArC,CAAb,CALK,CAK0E;AAC/E;AACA;;AAEA,QAAIK,gBAAgB,GAAGR,qBAAqB,CAACS,QAAtB,CAA+BlB,UAA/B,CAAvB;AACAE,IAAAA,WAAW,GAAGe,gBAAgB,GAAGX,OAAjC;AACD;;AAED,SAAO;AACLN,IAAAA,UAAU,EAAEA,UADP;AAELE,IAAAA,WAAW,EAAEA,WAFR;AAGLE,IAAAA,SAAS,EAAEA,SAHN;AAIL;AACA;AACAC,IAAAA,OAAO,EAAE;AANJ,GAAP;AAQD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASR,WAAT,CAAqBH,KAArB,EAA4ByB,QAA5B,EAAsC;AACpC,MAAIC,sBAAsB,GAAG,CAAC,GAAG7B,kBAAkB,CAAC,SAAD,CAAtB,EAAmCG,KAAnC,CAA7B;AAAA,MACIc,eAAe,GAAGY,sBAAsB,CAACZ,eAD7C;;AAGA,MAAIC,qBAAqB,GAAGf,KAAK,CAACe,qBAAlC;AAAA,MACIC,WAAW,GAAGhB,KAAK,CAACgB,WADxB;AAAA,MAEIW,aAAa,GAAG3B,KAAK,CAAC2B,aAF1B;AAAA,MAGIf,OAAO,GAAGZ,KAAK,CAACY,OAHpB;AAIA,MAAIM,SAAS,GAAGF,WAAW,CAACE,SAA5B;;AAEA,MAAIA,SAAS,KAAK,CAAlB,EAAqB;AACnB,WAAO;AACLZ,MAAAA,UAAU,EAAE,CADP;AAELE,MAAAA,WAAW,EAAE,CAFR;AAGLE,MAAAA,SAAS,EAAEN,SAHN;AAILO,MAAAA,OAAO,EAAEX,KAAK,CAACO,aAAN,KAAwB,CAAxB,IAA6BP,KAAK,CAACS,cAAN,KAAyB;AAJ1D,KAAP;AAMD;;AAEDgB,EAAAA,QAAQ,GAAG,CAAC,GAAGhC,MAAM,CAAC,SAAD,CAAV,EAAuBgC,QAAvB,EAAiC,CAAjC,EAAoCJ,IAAI,CAACC,GAAL,CAASJ,SAAS,GAAG,CAArB,EAAwB,CAAxB,CAApC,CAAX;AACA,GAAC,GAAGtB,gBAAgB,CAAC,SAAD,CAApB,EAAiCI,KAAjC,EAAwCyB,QAAxC;AACA,MAAIG,QAAQ,GAAGb,qBAAqB,CAACS,QAAtB,CAA+BC,QAA/B,CAAf;AACA,MAAII,MAAM,GAAGD,QAAQ,GAAGD,aAAa,CAACF,QAAD,CAArC;AACA,MAAInB,UAAU,GAAGmB,QAAjB;AACA,MAAIf,SAAS,GAAGN,SAAhB;;AAEA,MAAIwB,QAAQ,GAAGhB,OAAf,EAAwB,CAAC;AACvB;AACD,GAFD,MAEO,IAAIA,OAAO,GAAGE,eAAV,GAA4Be,MAAhC,EAAwC;AAC7C;AACAvB,IAAAA,UAAU,GAAGF,SAAb;AACAM,IAAAA,SAAS,GAAGe,QAAZ;AACD,GAJM,MAIA;AACL;AACA,WAAO;AACLnB,MAAAA,UAAU,EAAEN,KAAK,CAACO,aADb;AAELC,MAAAA,WAAW,EAAER,KAAK,CAACS,cAFd;AAGLC,MAAAA,SAAS,EAAEN,SAHN;AAILO,MAAAA,OAAO,EAAE;AAJJ,KAAP;AAMD;;AAED,SAAO;AACLL,IAAAA,UAAU,EAAEA,UADP;AAELE,IAAAA,WAAW,EAAE,CAFR;AAGLE,IAAAA,SAAS,EAAEA,SAHN;AAILC,IAAAA,OAAO,EAAE;AAJJ,GAAP;AAMD","sourcesContent":["/**\n * Copyright Schrodinger, LLC\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule scrollAnchor\n */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getScrollAnchor = getScrollAnchor;\nexports.scrollTo = scrollTo;\n\nvar _clamp = _interopRequireDefault(require('./clamp'));\n\nvar _updateRowHeight = _interopRequireDefault(require('./updateRowHeight'));\n\nvar _scrollbarsVisible = _interopRequireDefault(require('./scrollbarsVisible'));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/**\n * Get the anchor for scrolling.\n * This will either be the first row's index and an offset, or the last row's index.\n * We also pass a flag indicating if the anchor has changed from the state\n *\n * @param {!Object} state\n * @param {!Object} newProps\n * @param {!Object} oldProps\n * @return {{\n *   firstIndex: number,\n *   firstOffset: number,\n *   lastIndex: number,\n *   changed: boolean,\n * }}\n */\nfunction getScrollAnchor(state, newProps, oldProps) {\n  if (newProps.scrollToRow !== undefined && newProps.scrollToRow !== null && (!oldProps || newProps.scrollToRow !== oldProps.scrollToRow)) {\n    return scrollToRow(state, newProps.scrollToRow);\n  }\n\n  if (newProps.scrollTop !== undefined && newProps.scrollTop !== null && (!oldProps || newProps.scrollTop !== oldProps.scrollTop)) {\n    return scrollTo(state, newProps.scrollTop);\n  }\n\n  return {\n    firstIndex: state.firstRowIndex,\n    firstOffset: state.firstRowOffset,\n    lastIndex: undefined,\n    changed: false\n  };\n}\n/**\n * Scroll to a specific position in the grid\n *\n * @param {!Object} state\n * @param {number} scrollY\n * @return {{\n *   firstIndex: number,\n *   firstOffset: number,\n *   lastIndex: number,\n *   changed: boolean,\n * }}\n */\n\n\nfunction scrollTo(state, scrollY) {\n  var _scrollbarsVisibleSel = (0, _scrollbarsVisible[\"default\"])(state),\n      availableHeight = _scrollbarsVisibleSel.availableHeight;\n\n  var rowOffsetIntervalTree = state.rowOffsetIntervalTree,\n      rowSettings = state.rowSettings,\n      scrollContentHeight = state.scrollContentHeight;\n  var rowsCount = rowSettings.rowsCount;\n\n  if (rowsCount === 0) {\n    return {\n      firstIndex: 0,\n      firstOffset: 0,\n      lastIndex: undefined,\n      changed: state.firstRowIndex !== 0 || state.firstRowOffset !== 0\n    };\n  }\n\n  var firstIndex = 0;\n  var firstOffset = 0;\n  var lastIndex = undefined;\n\n  if (scrollY <= 0) {// Use defaults (from above) to scroll to first row\n  } else if (scrollY >= scrollContentHeight - availableHeight) {\n    // Scroll to the last row\n    firstIndex = undefined;\n    lastIndex = rowsCount - 1;\n  } else {\n    // Mark the row which will appear first in the viewport\n    // We use this as our \"marker\" when scrolling even if updating rowOffsets\n    // leads to it not being different from the scrollY specified\n    var newRowIdx = rowOffsetIntervalTree.greatestLowerBound(scrollY);\n    firstIndex = (0, _clamp[\"default\"])(newRowIdx, 0, Math.max(rowsCount - 1, 0)); // Record how far into the first row we should scroll\n    // firstOffset is a negative value representing how much larger scrollY is\n    // than the scroll position of the first row in the viewport\n\n    var firstRowPosition = rowOffsetIntervalTree.sumUntil(firstIndex);\n    firstOffset = firstRowPosition - scrollY;\n  }\n\n  return {\n    firstIndex: firstIndex,\n    firstOffset: firstOffset,\n    lastIndex: lastIndex,\n    // NOTE (jordan) This changed heuristic may give false positives,\n    // but that's fine since it's used as a filter to computeRenderedRows\n    changed: true\n  };\n}\n/**\n * Scroll a specified row into the viewport\n * If the row is before the viewport, it will become the first row in the viewport\n * If the row is after the viewport, it will become the last row in the viewport\n * If the row is in the viewport, do nothing\n *\n * @param {!Object} state\n * @param {number} rowIndex\n * @return {{\n *   firstIndex: number,\n *   firstOffset: number,\n *   lastIndex: number,\n *   changed: boolean,\n * }}\n * @private\n */\n\n\nfunction scrollToRow(state, rowIndex) {\n  var _scrollbarsVisibleSel2 = (0, _scrollbarsVisible[\"default\"])(state),\n      availableHeight = _scrollbarsVisibleSel2.availableHeight;\n\n  var rowOffsetIntervalTree = state.rowOffsetIntervalTree,\n      rowSettings = state.rowSettings,\n      storedHeights = state.storedHeights,\n      scrollY = state.scrollY;\n  var rowsCount = rowSettings.rowsCount;\n\n  if (rowsCount === 0) {\n    return {\n      firstIndex: 0,\n      firstOffset: 0,\n      lastIndex: undefined,\n      changed: state.firstRowIndex !== 0 || state.firstRowOffset !== 0\n    };\n  }\n\n  rowIndex = (0, _clamp[\"default\"])(rowIndex, 0, Math.max(rowsCount - 1, 0));\n  (0, _updateRowHeight[\"default\"])(state, rowIndex);\n  var rowBegin = rowOffsetIntervalTree.sumUntil(rowIndex);\n  var rowEnd = rowBegin + storedHeights[rowIndex];\n  var firstIndex = rowIndex;\n  var lastIndex = undefined;\n\n  if (rowBegin < scrollY) {// If before the viewport, set as the first row in the viewport\n    // Uses defaults (from above)\n  } else if (scrollY + availableHeight < rowEnd) {\n    // If after the viewport, set as the last row in the viewport\n    firstIndex = undefined;\n    lastIndex = rowIndex;\n  } else {\n    // If already in the viewport, do nothing.\n    return {\n      firstIndex: state.firstRowIndex,\n      firstOffset: state.firstRowOffset,\n      lastIndex: undefined,\n      changed: false\n    };\n  }\n\n  return {\n    firstIndex: firstIndex,\n    firstOffset: 0,\n    lastIndex: lastIndex,\n    changed: true\n  };\n}"]},"metadata":{},"sourceType":"script"}