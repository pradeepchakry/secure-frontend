{"ast":null,"code":"/**\n * Copyright Schrodinger, LLC\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule IntegerBufferSet\n * @typechecks\n */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _Heap = _interopRequireDefault(require('./Heap'));\n\nvar _invariant = _interopRequireDefault(require('./invariant'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n} // Data structure that allows to store values and assign positions to them\n// in a way to minimize changing positions of stored values when new ones are\n// added or when some values are replaced. Stored elements are alwasy assigned\n// a consecutive set of positoins startin from 0 up to count of elements less 1\n// Following actions can be executed\n// * get position assigned to given value (null if value is not stored)\n// * create new entry for new value and get assigned position back\n// * replace value that is furthest from specified value range with new value\n//   and get it's position back\n// All operations take amortized log(n) time where n is number of elements in\n// the set.\n\n\nvar IntegerBufferSet = /*#__PURE__*/function () {\n  function IntegerBufferSet() {\n    _classCallCheck(this, IntegerBufferSet);\n\n    this._valueToPositionMap = {};\n    this._size = 0;\n    this._smallValues = new _Heap[\"default\"]([], // Initial data in the heap\n    this._smallerComparator);\n    this._largeValues = new _Heap[\"default\"]([], // Initial data in the heap\n    this._greaterComparator);\n    this.getNewPositionForValue = this.getNewPositionForValue.bind(this);\n    this.getValuePosition = this.getValuePosition.bind(this);\n    this.getSize = this.getSize.bind(this);\n    this.replaceFurthestValuePosition = this.replaceFurthestValuePosition.bind(this);\n  }\n\n  _createClass(IntegerBufferSet, [{\n    key: \"getSize\",\n    value: function getSize()\n    /*number*/\n    {\n      return this._size;\n    }\n  }, {\n    key: \"getValuePosition\",\n    value: function getValuePosition(\n    /*number*/\n    value)\n    /*?number*/\n    {\n      if (this._valueToPositionMap[value] === undefined) {\n        return null;\n      }\n\n      return this._valueToPositionMap[value];\n    }\n  }, {\n    key: \"getNewPositionForValue\",\n    value: function getNewPositionForValue(\n    /*number*/\n    value)\n    /*number*/\n    {\n      (0, _invariant[\"default\"])(this._valueToPositionMap[value] === undefined, \"Shouldn't try to find new position for value already stored in BufferSet\");\n      var newPosition = this._size;\n      this._size++;\n\n      this._pushToHeaps(newPosition, value);\n\n      this._valueToPositionMap[value] = newPosition;\n      return newPosition;\n    }\n  }, {\n    key: \"replaceFurthestValuePosition\",\n    value: function replaceFurthestValuePosition(\n    /*number*/\n    lowValue,\n    /*number*/\n    highValue,\n    /*number*/\n    newValue)\n    /*?number*/\n    {\n      (0, _invariant[\"default\"])(this._valueToPositionMap[newValue] === undefined, \"Shouldn't try to replace values with value already stored value in \" + \"BufferSet\");\n\n      this._cleanHeaps();\n\n      if (this._smallValues.empty() || this._largeValues.empty()) {\n        // Threre are currently no values stored. We will have to create new\n        // position for this value.\n        return null;\n      }\n\n      var minValue = this._smallValues.peek().value;\n\n      var maxValue = this._largeValues.peek().value;\n\n      if (minValue >= lowValue && maxValue <= highValue) {\n        // All values currently stored are necessary, we can't reuse any of them.\n        return null;\n      }\n\n      var valueToReplace;\n\n      if (lowValue - minValue > maxValue - highValue) {\n        // minValue is further from provided range. We will reuse it's position.\n        valueToReplace = minValue;\n\n        this._smallValues.pop();\n      } else {\n        valueToReplace = maxValue;\n\n        this._largeValues.pop();\n      }\n\n      var position = this._valueToPositionMap[valueToReplace];\n      delete this._valueToPositionMap[valueToReplace];\n      this._valueToPositionMap[newValue] = position;\n\n      this._pushToHeaps(position, newValue);\n\n      return position;\n    }\n  }, {\n    key: \"_pushToHeaps\",\n    value: function _pushToHeaps(\n    /*number*/\n    position,\n    /*number*/\n    value) {\n      var element = {\n        position: position,\n        value: value\n      }; // We can reuse the same object in both heaps, because we don't mutate them\n\n      this._smallValues.push(element);\n\n      this._largeValues.push(element);\n    }\n  }, {\n    key: \"_cleanHeaps\",\n    value: function _cleanHeaps() {\n      // We not usually only remove object from one heap while moving value.\n      // Here we make sure that there is no stale data on top of heaps.\n      this._cleanHeap(this._smallValues);\n\n      this._cleanHeap(this._largeValues);\n\n      var minHeapSize = Math.min(this._smallValues.size(), this._largeValues.size());\n      var maxHeapSize = Math.max(this._smallValues.size(), this._largeValues.size());\n\n      if (maxHeapSize > 10 * minHeapSize) {\n        // There are many old values in one of heaps. We nned to get rid of them\n        // to not use too avoid memory leaks\n        this._recreateHeaps();\n      }\n    }\n  }, {\n    key: \"_recreateHeaps\",\n    value: function _recreateHeaps() {\n      var sourceHeap = this._smallValues.size() < this._largeValues.size() ? this._smallValues : this._largeValues;\n      var newSmallValues = new _Heap[\"default\"]([], // Initial data in the heap\n      this._smallerComparator);\n      var newLargeValues = new _Heap[\"default\"]([], // Initial datat in the heap\n      this._greaterComparator);\n\n      while (!sourceHeap.empty()) {\n        var element = sourceHeap.pop(); // Push all stil valid elements to new heaps\n\n        if (this._valueToPositionMap[element.value] !== undefined) {\n          newSmallValues.push(element);\n          newLargeValues.push(element);\n        }\n      }\n\n      this._smallValues = newSmallValues;\n      this._largeValues = newLargeValues;\n    }\n  }, {\n    key: \"_cleanHeap\",\n    value: function _cleanHeap(\n    /*object*/\n    heap) {\n      while (!heap.empty() && this._valueToPositionMap[heap.peek().value] === undefined) {\n        heap.pop();\n      }\n    }\n  }, {\n    key: \"_smallerComparator\",\n    value: function _smallerComparator(\n    /*object*/\n    lhs,\n    /*object*/\n    rhs)\n    /*boolean*/\n    {\n      return lhs.value < rhs.value;\n    }\n  }, {\n    key: \"_greaterComparator\",\n    value: function _greaterComparator(\n    /*object*/\n    lhs,\n    /*object*/\n    rhs)\n    /*boolean*/\n    {\n      return lhs.value > rhs.value;\n    }\n  }]);\n\n  return IntegerBufferSet;\n}();\n\nvar _default = IntegerBufferSet;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["/home/discovery/Documents/secure-frontend/node_modules/fixed-data-table-2/internal/IntegerBufferSet.js"],"names":["Object","defineProperty","exports","value","_Heap","_interopRequireDefault","require","_invariant","obj","__esModule","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","_createClass","protoProps","staticProps","prototype","IntegerBufferSet","_valueToPositionMap","_size","_smallValues","_smallerComparator","_largeValues","_greaterComparator","getNewPositionForValue","bind","getValuePosition","getSize","replaceFurthestValuePosition","undefined","newPosition","_pushToHeaps","lowValue","highValue","newValue","_cleanHeaps","empty","minValue","peek","maxValue","valueToReplace","pop","position","element","push","_cleanHeap","minHeapSize","Math","min","size","maxHeapSize","max","_recreateHeaps","sourceHeap","newSmallValues","newLargeValues","heap","lhs","rhs","_default"],"mappings":"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","sourcesContent":["/**\n * Copyright Schrodinger, LLC\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule IntegerBufferSet\n * @typechecks\n */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _Heap = _interopRequireDefault(require('./Heap'));\n\nvar _invariant = _interopRequireDefault(require('./invariant'));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// Data structure that allows to store values and assign positions to them\n// in a way to minimize changing positions of stored values when new ones are\n// added or when some values are replaced. Stored elements are alwasy assigned\n// a consecutive set of positoins startin from 0 up to count of elements less 1\n// Following actions can be executed\n// * get position assigned to given value (null if value is not stored)\n// * create new entry for new value and get assigned position back\n// * replace value that is furthest from specified value range with new value\n//   and get it's position back\n// All operations take amortized log(n) time where n is number of elements in\n// the set.\nvar IntegerBufferSet = /*#__PURE__*/function () {\n  function IntegerBufferSet() {\n    _classCallCheck(this, IntegerBufferSet);\n\n    this._valueToPositionMap = {};\n    this._size = 0;\n    this._smallValues = new _Heap[\"default\"]([], // Initial data in the heap\n    this._smallerComparator);\n    this._largeValues = new _Heap[\"default\"]([], // Initial data in the heap\n    this._greaterComparator);\n    this.getNewPositionForValue = this.getNewPositionForValue.bind(this);\n    this.getValuePosition = this.getValuePosition.bind(this);\n    this.getSize = this.getSize.bind(this);\n    this.replaceFurthestValuePosition = this.replaceFurthestValuePosition.bind(this);\n  }\n\n  _createClass(IntegerBufferSet, [{\n    key: \"getSize\",\n    value: function getSize()\n    /*number*/\n    {\n      return this._size;\n    }\n  }, {\n    key: \"getValuePosition\",\n    value: function getValuePosition(\n    /*number*/\n    value)\n    /*?number*/\n    {\n      if (this._valueToPositionMap[value] === undefined) {\n        return null;\n      }\n\n      return this._valueToPositionMap[value];\n    }\n  }, {\n    key: \"getNewPositionForValue\",\n    value: function getNewPositionForValue(\n    /*number*/\n    value)\n    /*number*/\n    {\n      (0, _invariant[\"default\"])(this._valueToPositionMap[value] === undefined, \"Shouldn't try to find new position for value already stored in BufferSet\");\n      var newPosition = this._size;\n      this._size++;\n\n      this._pushToHeaps(newPosition, value);\n\n      this._valueToPositionMap[value] = newPosition;\n      return newPosition;\n    }\n  }, {\n    key: \"replaceFurthestValuePosition\",\n    value: function replaceFurthestValuePosition(\n    /*number*/\n    lowValue,\n    /*number*/\n    highValue,\n    /*number*/\n    newValue)\n    /*?number*/\n    {\n      (0, _invariant[\"default\"])(this._valueToPositionMap[newValue] === undefined, \"Shouldn't try to replace values with value already stored value in \" + \"BufferSet\");\n\n      this._cleanHeaps();\n\n      if (this._smallValues.empty() || this._largeValues.empty()) {\n        // Threre are currently no values stored. We will have to create new\n        // position for this value.\n        return null;\n      }\n\n      var minValue = this._smallValues.peek().value;\n\n      var maxValue = this._largeValues.peek().value;\n\n      if (minValue >= lowValue && maxValue <= highValue) {\n        // All values currently stored are necessary, we can't reuse any of them.\n        return null;\n      }\n\n      var valueToReplace;\n\n      if (lowValue - minValue > maxValue - highValue) {\n        // minValue is further from provided range. We will reuse it's position.\n        valueToReplace = minValue;\n\n        this._smallValues.pop();\n      } else {\n        valueToReplace = maxValue;\n\n        this._largeValues.pop();\n      }\n\n      var position = this._valueToPositionMap[valueToReplace];\n      delete this._valueToPositionMap[valueToReplace];\n      this._valueToPositionMap[newValue] = position;\n\n      this._pushToHeaps(position, newValue);\n\n      return position;\n    }\n  }, {\n    key: \"_pushToHeaps\",\n    value: function _pushToHeaps(\n    /*number*/\n    position,\n    /*number*/\n    value) {\n      var element = {\n        position: position,\n        value: value\n      }; // We can reuse the same object in both heaps, because we don't mutate them\n\n      this._smallValues.push(element);\n\n      this._largeValues.push(element);\n    }\n  }, {\n    key: \"_cleanHeaps\",\n    value: function _cleanHeaps() {\n      // We not usually only remove object from one heap while moving value.\n      // Here we make sure that there is no stale data on top of heaps.\n      this._cleanHeap(this._smallValues);\n\n      this._cleanHeap(this._largeValues);\n\n      var minHeapSize = Math.min(this._smallValues.size(), this._largeValues.size());\n      var maxHeapSize = Math.max(this._smallValues.size(), this._largeValues.size());\n\n      if (maxHeapSize > 10 * minHeapSize) {\n        // There are many old values in one of heaps. We nned to get rid of them\n        // to not use too avoid memory leaks\n        this._recreateHeaps();\n      }\n    }\n  }, {\n    key: \"_recreateHeaps\",\n    value: function _recreateHeaps() {\n      var sourceHeap = this._smallValues.size() < this._largeValues.size() ? this._smallValues : this._largeValues;\n      var newSmallValues = new _Heap[\"default\"]([], // Initial data in the heap\n      this._smallerComparator);\n      var newLargeValues = new _Heap[\"default\"]([], // Initial datat in the heap\n      this._greaterComparator);\n\n      while (!sourceHeap.empty()) {\n        var element = sourceHeap.pop(); // Push all stil valid elements to new heaps\n\n        if (this._valueToPositionMap[element.value] !== undefined) {\n          newSmallValues.push(element);\n          newLargeValues.push(element);\n        }\n      }\n\n      this._smallValues = newSmallValues;\n      this._largeValues = newLargeValues;\n    }\n  }, {\n    key: \"_cleanHeap\",\n    value: function _cleanHeap(\n    /*object*/\n    heap) {\n      while (!heap.empty() && this._valueToPositionMap[heap.peek().value] === undefined) {\n        heap.pop();\n      }\n    }\n  }, {\n    key: \"_smallerComparator\",\n    value: function _smallerComparator(\n    /*object*/\n    lhs,\n    /*object*/\n    rhs)\n    /*boolean*/\n    {\n      return lhs.value < rhs.value;\n    }\n  }, {\n    key: \"_greaterComparator\",\n    value: function _greaterComparator(\n    /*object*/\n    lhs,\n    /*object*/\n    rhs)\n    /*boolean*/\n    {\n      return lhs.value > rhs.value;\n    }\n  }]);\n\n  return IntegerBufferSet;\n}();\n\nvar _default = IntegerBufferSet;\nexports[\"default\"] = _default;"]},"metadata":{},"sourceType":"script"}