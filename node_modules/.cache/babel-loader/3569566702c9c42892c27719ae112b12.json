{"ast":null,"code":"/**\n * Copyright Schrodinger, LLC\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule computeRenderedRows\n */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = computeRenderedRows;\n\nvar _clamp = _interopRequireDefault(require('lodash/clamp'));\n\nvar _updateRowHeight = _interopRequireDefault(require('./updateRowHeight'));\n\nvar _roughHeights = _interopRequireDefault(require('./roughHeights'));\n\nvar _scrollbarsVisible = _interopRequireDefault(require('./scrollbarsVisible'));\n\nvar _tableHeights = _interopRequireDefault(require('./tableHeights'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n/**\n * Returns data about the rows to render\n * rows is a map of rowIndexes to render to their heights\n * firstRowIndex & firstRowOffset are calculated based on the lastIndex if\n * specified in scrollAnchor.\n * Otherwise, they are unchanged from the firstIndex & firstOffset scrollAnchor values.\n *\n * @param {!Object} state\n * @param {{\n *   firstIndex: number,\n *   firstOffset: number,\n *   lastIndex: number,\n * }} scrollAnchor\n * @return {!Object} The updated state object\n */\n\n\nfunction computeRenderedRows(state, scrollAnchor) {\n  var newState = _extends({}, state);\n\n  var rowRange = calculateRenderedRowRange(newState, scrollAnchor);\n  var rowSettings = newState.rowSettings,\n      scrollContentHeight = newState.scrollContentHeight;\n  var rowsCount = rowSettings.rowsCount;\n\n  var _tableHeightsSelector = (0, _tableHeights[\"default\"])(newState),\n      bodyHeight = _tableHeightsSelector.bodyHeight;\n\n  var maxScrollY = scrollContentHeight - bodyHeight;\n  var firstRowOffset; // NOTE (jordan) This handles #115 where resizing the viewport may\n  // leave only a subset of rows shown, but no scrollbar to scroll up to the first rows.\n\n  if (maxScrollY === 0) {\n    if (rowRange.firstViewportIdx > 0) {\n      rowRange = calculateRenderedRowRange(newState, {\n        firstOffset: 0,\n        lastIndex: rowsCount - 1\n      });\n    }\n\n    firstRowOffset = 0;\n  } else {\n    firstRowOffset = rowRange.firstOffset;\n  }\n\n  var firstRowIndex = rowRange.firstViewportIdx;\n  var endRowIndex = rowRange.endViewportIdx;\n  computeRenderedRowOffsets(newState, rowRange, state.scrolling);\n  var scrollY = 0;\n\n  if (rowsCount > 0) {\n    scrollY = newState.rowOffsets[rowRange.firstViewportIdx] - firstRowOffset;\n  }\n\n  scrollY = (0, _clamp[\"default\"])(scrollY, 0, maxScrollY);\n  return _extends(newState, {\n    firstRowIndex: firstRowIndex,\n    firstRowOffset: firstRowOffset,\n    endRowIndex: endRowIndex,\n    maxScrollY: maxScrollY,\n    scrollY: scrollY\n  });\n}\n/**\n * Determine the range of rows to render (buffer and viewport)\n * The leading and trailing buffer is based on a fixed count,\n * while the viewport rows are based on their height and the viewport height\n * We use the scrollAnchor to determine what either the first or last row\n * will be, as well as the offset.\n *\n * NOTE (jordan) This alters state so it shouldn't be called\n * without state having been cloned first.\n *\n * @param {!Object} state\n * @param {{\n *   firstIndex: number,\n *   firstOffset: number,\n *   lastIndex: number,\n * }} scrollAnchor\n * @return {{\n *   endBufferIdx: number,\n *   endViewportIdx: number,\n *   firstBufferIdx: number,\n *   firstOffset: number,\n *   firstViewportIdx: number,\n * }}\n * @private\n */\n\n\nfunction calculateRenderedRowRange(state, scrollAnchor) {\n  var _roughHeightsSelector = (0, _roughHeights[\"default\"])(state),\n      bufferRowCount = _roughHeightsSelector.bufferRowCount,\n      maxAvailableHeight = _roughHeightsSelector.maxAvailableHeight;\n\n  var rowsCount = state.rowSettings.rowsCount;\n\n  if (rowsCount === 0) {\n    return {\n      endBufferIdx: 0,\n      endViewportIdx: 0,\n      firstBufferIdx: 0,\n      firstOffset: 0,\n      firstViewportIdx: 0\n    };\n  } // If our first or last index is greater than our rowsCount,\n  // treat it as if the last row is at the bottom of the viewport\n\n\n  var firstIndex = scrollAnchor.firstIndex,\n      firstOffset = scrollAnchor.firstOffset,\n      lastIndex = scrollAnchor.lastIndex;\n\n  if (firstIndex >= rowsCount || lastIndex >= rowsCount) {\n    lastIndex = rowsCount - 1;\n  } // Walk the viewport until filled with rows\n  // If lastIndex is set, walk backward so that row is the last in the viewport\n\n\n  var step = 1;\n  var startIdx = firstIndex;\n  var totalHeight = firstOffset;\n\n  if (lastIndex !== undefined) {\n    step = -1;\n    startIdx = lastIndex;\n    totalHeight = 0;\n  } // Loop to walk the viewport until we've touched enough rows to fill its height\n\n\n  var rowIdx = startIdx;\n  var endIdx = rowIdx;\n\n  while (rowIdx < rowsCount && rowIdx >= 0 && totalHeight < maxAvailableHeight) {\n    totalHeight += (0, _updateRowHeight[\"default\"])(state, rowIdx);\n    endIdx = rowIdx;\n    rowIdx += step;\n  }\n  /* Handle the case where rows have shrunk and there's not enough content\n     between the start scroll anchor and the end of the table to fill the available space.\n     In this case process earlier rows as needed and act as if we've scrolled to the last row.\n   */\n\n\n  var forceScrollToLastRow = false;\n\n  if (totalHeight < maxAvailableHeight && rowIdx === rowsCount && lastIndex === undefined) {\n    forceScrollToLastRow = true;\n    rowIdx = firstIndex - 1;\n\n    while (rowIdx >= 0 && totalHeight < maxAvailableHeight) {\n      totalHeight += (0, _updateRowHeight[\"default\"])(state, rowIdx);\n      startIdx = rowIdx;\n      --rowIdx;\n    }\n  } // Loop to walk the leading buffer\n\n\n  var firstViewportIdx = Math.min(startIdx, endIdx);\n  var firstBufferIdx = Math.max(firstViewportIdx - bufferRowCount, 0);\n\n  for (rowIdx = firstBufferIdx; rowIdx < firstViewportIdx; rowIdx++) {\n    (0, _updateRowHeight[\"default\"])(state, rowIdx);\n  } // Loop to walk the trailing buffer\n\n\n  var endViewportIdx = Math.max(startIdx, endIdx) + 1;\n  var endBufferIdx = Math.min(endViewportIdx + bufferRowCount, rowsCount);\n\n  for (rowIdx = endViewportIdx; rowIdx < endBufferIdx; rowIdx++) {\n    (0, _updateRowHeight[\"default\"])(state, rowIdx);\n  }\n\n  var _scrollbarsVisibleSel = (0, _scrollbarsVisible[\"default\"])(state),\n      availableHeight = _scrollbarsVisibleSel.availableHeight;\n\n  if (lastIndex !== undefined || forceScrollToLastRow) {\n    // Calculate offset needed to position last row at bottom of viewport\n    // This should be negative and represent how far the first row needs to be offscreen\n    // NOTE (jordan): The first offset should always be 0 when lastIndex is defined\n    // since we don't currently support scrolling the last row into view with an offset.\n    firstOffset = firstOffset + Math.min(availableHeight - totalHeight, 0); // Handle a case where the offset puts the first row fully offscreen\n    // This can happen if availableHeight & maxAvailableHeight are different\n\n    var storedHeights = state.storedHeights;\n\n    if (-1 * firstOffset >= storedHeights[firstViewportIdx]) {\n      firstViewportIdx += 1;\n      firstOffset += storedHeights[firstViewportIdx];\n    }\n  }\n\n  return {\n    endBufferIdx: endBufferIdx,\n    endViewportIdx: endViewportIdx,\n    firstBufferIdx: firstBufferIdx,\n    firstOffset: firstOffset,\n    firstViewportIdx: firstViewportIdx\n  };\n}\n/**\n * Walk the rows to render and compute the height offsets and\n * positions in the row buffer.\n *\n * NOTE (jordan) This alters state so it shouldn't be called\n * without state having been cloned first.\n *\n * @param {!Object} state\n * @param {{\n *   endBufferIdx: number,\n *   endViewportIdx: number,\n *   firstBufferIdx: number,\n *   firstViewportIdx: number,\n * }} rowRange\n * @param {boolean} viewportOnly\n * @private\n */\n\n\nfunction computeRenderedRowOffsets(state, rowRange, viewportOnly) {\n  var rowBufferSet = state.rowBufferSet,\n      rowOffsetIntervalTree = state.rowOffsetIntervalTree,\n      storedHeights = state.storedHeights;\n  var endBufferIdx = rowRange.endBufferIdx,\n      endViewportIdx = rowRange.endViewportIdx,\n      firstBufferIdx = rowRange.firstBufferIdx,\n      firstViewportIdx = rowRange.firstViewportIdx;\n  var renderedRowsCount = endBufferIdx - firstBufferIdx;\n\n  if (renderedRowsCount === 0) {\n    state.rowOffsets = {};\n    state.rows = [];\n    return;\n  }\n\n  var startIdx = viewportOnly ? firstViewportIdx : firstBufferIdx;\n  var endIdx = viewportOnly ? endViewportIdx : endBufferIdx; // output for this function\n\n  var rows = []; // state.rows\n\n  var rowOffsets = {}; // state.rowOffsets\n  // incremental way for calculating rowOffset\n\n  var runningOffset = rowOffsetIntervalTree.sumUntil(startIdx); // compute row index and offsets for every rows inside the buffer\n\n  for (var rowIdx = startIdx; rowIdx < endIdx; rowIdx++) {\n    // Update the offset for rendering the row\n    rowOffsets[rowIdx] = runningOffset;\n    runningOffset += storedHeights[rowIdx]; // Get position for the viewport row\n\n    var rowPosition = addRowToBuffer(rowIdx, rowBufferSet, startIdx, endIdx, renderedRowsCount);\n    rows[rowPosition] = rowIdx;\n  } // now we modify the state with the newly calculated rows and offsets\n\n\n  state.rows = rows;\n  state.rowOffsets = rowOffsets;\n}\n/**\n * Add the row to the buffer set if it doesn't exist.\n * If addition isn't possible due to max buffer size, it'll replace an existing element outside the given range.\n *\n * @param {!number} rowIdx\n * @param {!number} rowBufferSet\n * @param {!number} startRange\n * @param {!number} endRange\n * @param {!number} maxBufferSize\n *\n * @return {?number} the position of the row after being added to the buffer set\n * @private\n */\n\n\nfunction addRowToBuffer(rowIdx, rowBufferSet, startRange, endRange, maxBufferSize) {\n  // Check if row already has a position in the buffer\n  var rowPosition = rowBufferSet.getValuePosition(rowIdx); // Request a position in the buffer through eviction of another row\n\n  if (rowPosition === null && rowBufferSet.getSize() >= maxBufferSize) {\n    rowPosition = rowBufferSet.replaceFurthestValuePosition(startRange, endRange - 1, // replaceFurthestValuePosition uses closed interval from startRange to endRange\n    rowIdx);\n  }\n\n  if (rowPosition === null) {\n    rowPosition = rowBufferSet.getNewPositionForValue(rowIdx);\n  }\n\n  return rowPosition;\n}","map":{"version":3,"sources":["/home/discovery/Documents/secure-frontend/node_modules/fixed-data-table-2/internal/computeRenderedRows.js"],"names":["Object","defineProperty","exports","value","computeRenderedRows","_clamp","_interopRequireDefault","require","_updateRowHeight","_roughHeights","_scrollbarsVisible","_tableHeights","obj","__esModule","_extends","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","state","scrollAnchor","newState","rowRange","calculateRenderedRowRange","rowSettings","scrollContentHeight","rowsCount","_tableHeightsSelector","bodyHeight","maxScrollY","firstRowOffset","firstViewportIdx","firstOffset","lastIndex","firstRowIndex","endRowIndex","endViewportIdx","computeRenderedRowOffsets","scrolling","scrollY","rowOffsets","_roughHeightsSelector","bufferRowCount","maxAvailableHeight","endBufferIdx","firstBufferIdx","firstIndex","step","startIdx","totalHeight","undefined","rowIdx","endIdx","forceScrollToLastRow","Math","min","max","_scrollbarsVisibleSel","availableHeight","storedHeights","viewportOnly","rowBufferSet","rowOffsetIntervalTree","renderedRowsCount","rows","runningOffset","sumUntil","rowPosition","addRowToBuffer","startRange","endRange","maxBufferSize","getValuePosition","getSize","replaceFurthestValuePosition","getNewPositionForValue"],"mappings":"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","sourcesContent":["/**\n * Copyright Schrodinger, LLC\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule computeRenderedRows\n */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = computeRenderedRows;\n\nvar _clamp = _interopRequireDefault(require('lodash/clamp'));\n\nvar _updateRowHeight = _interopRequireDefault(require('./updateRowHeight'));\n\nvar _roughHeights = _interopRequireDefault(require('./roughHeights'));\n\nvar _scrollbarsVisible = _interopRequireDefault(require('./scrollbarsVisible'));\n\nvar _tableHeights = _interopRequireDefault(require('./tableHeights'));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n/**\n * Returns data about the rows to render\n * rows is a map of rowIndexes to render to their heights\n * firstRowIndex & firstRowOffset are calculated based on the lastIndex if\n * specified in scrollAnchor.\n * Otherwise, they are unchanged from the firstIndex & firstOffset scrollAnchor values.\n *\n * @param {!Object} state\n * @param {{\n *   firstIndex: number,\n *   firstOffset: number,\n *   lastIndex: number,\n * }} scrollAnchor\n * @return {!Object} The updated state object\n */\nfunction computeRenderedRows(state, scrollAnchor) {\n  var newState = _extends({}, state);\n\n  var rowRange = calculateRenderedRowRange(newState, scrollAnchor);\n  var rowSettings = newState.rowSettings,\n      scrollContentHeight = newState.scrollContentHeight;\n  var rowsCount = rowSettings.rowsCount;\n\n  var _tableHeightsSelector = (0, _tableHeights[\"default\"])(newState),\n      bodyHeight = _tableHeightsSelector.bodyHeight;\n\n  var maxScrollY = scrollContentHeight - bodyHeight;\n  var firstRowOffset; // NOTE (jordan) This handles #115 where resizing the viewport may\n  // leave only a subset of rows shown, but no scrollbar to scroll up to the first rows.\n\n  if (maxScrollY === 0) {\n    if (rowRange.firstViewportIdx > 0) {\n      rowRange = calculateRenderedRowRange(newState, {\n        firstOffset: 0,\n        lastIndex: rowsCount - 1\n      });\n    }\n\n    firstRowOffset = 0;\n  } else {\n    firstRowOffset = rowRange.firstOffset;\n  }\n\n  var firstRowIndex = rowRange.firstViewportIdx;\n  var endRowIndex = rowRange.endViewportIdx;\n  computeRenderedRowOffsets(newState, rowRange, state.scrolling);\n  var scrollY = 0;\n\n  if (rowsCount > 0) {\n    scrollY = newState.rowOffsets[rowRange.firstViewportIdx] - firstRowOffset;\n  }\n\n  scrollY = (0, _clamp[\"default\"])(scrollY, 0, maxScrollY);\n  return _extends(newState, {\n    firstRowIndex: firstRowIndex,\n    firstRowOffset: firstRowOffset,\n    endRowIndex: endRowIndex,\n    maxScrollY: maxScrollY,\n    scrollY: scrollY\n  });\n}\n/**\n * Determine the range of rows to render (buffer and viewport)\n * The leading and trailing buffer is based on a fixed count,\n * while the viewport rows are based on their height and the viewport height\n * We use the scrollAnchor to determine what either the first or last row\n * will be, as well as the offset.\n *\n * NOTE (jordan) This alters state so it shouldn't be called\n * without state having been cloned first.\n *\n * @param {!Object} state\n * @param {{\n *   firstIndex: number,\n *   firstOffset: number,\n *   lastIndex: number,\n * }} scrollAnchor\n * @return {{\n *   endBufferIdx: number,\n *   endViewportIdx: number,\n *   firstBufferIdx: number,\n *   firstOffset: number,\n *   firstViewportIdx: number,\n * }}\n * @private\n */\n\n\nfunction calculateRenderedRowRange(state, scrollAnchor) {\n  var _roughHeightsSelector = (0, _roughHeights[\"default\"])(state),\n      bufferRowCount = _roughHeightsSelector.bufferRowCount,\n      maxAvailableHeight = _roughHeightsSelector.maxAvailableHeight;\n\n  var rowsCount = state.rowSettings.rowsCount;\n\n  if (rowsCount === 0) {\n    return {\n      endBufferIdx: 0,\n      endViewportIdx: 0,\n      firstBufferIdx: 0,\n      firstOffset: 0,\n      firstViewportIdx: 0\n    };\n  } // If our first or last index is greater than our rowsCount,\n  // treat it as if the last row is at the bottom of the viewport\n\n\n  var firstIndex = scrollAnchor.firstIndex,\n      firstOffset = scrollAnchor.firstOffset,\n      lastIndex = scrollAnchor.lastIndex;\n\n  if (firstIndex >= rowsCount || lastIndex >= rowsCount) {\n    lastIndex = rowsCount - 1;\n  } // Walk the viewport until filled with rows\n  // If lastIndex is set, walk backward so that row is the last in the viewport\n\n\n  var step = 1;\n  var startIdx = firstIndex;\n  var totalHeight = firstOffset;\n\n  if (lastIndex !== undefined) {\n    step = -1;\n    startIdx = lastIndex;\n    totalHeight = 0;\n  } // Loop to walk the viewport until we've touched enough rows to fill its height\n\n\n  var rowIdx = startIdx;\n  var endIdx = rowIdx;\n\n  while (rowIdx < rowsCount && rowIdx >= 0 && totalHeight < maxAvailableHeight) {\n    totalHeight += (0, _updateRowHeight[\"default\"])(state, rowIdx);\n    endIdx = rowIdx;\n    rowIdx += step;\n  }\n  /* Handle the case where rows have shrunk and there's not enough content\n     between the start scroll anchor and the end of the table to fill the available space.\n     In this case process earlier rows as needed and act as if we've scrolled to the last row.\n   */\n\n\n  var forceScrollToLastRow = false;\n\n  if (totalHeight < maxAvailableHeight && rowIdx === rowsCount && lastIndex === undefined) {\n    forceScrollToLastRow = true;\n    rowIdx = firstIndex - 1;\n\n    while (rowIdx >= 0 && totalHeight < maxAvailableHeight) {\n      totalHeight += (0, _updateRowHeight[\"default\"])(state, rowIdx);\n      startIdx = rowIdx;\n      --rowIdx;\n    }\n  } // Loop to walk the leading buffer\n\n\n  var firstViewportIdx = Math.min(startIdx, endIdx);\n  var firstBufferIdx = Math.max(firstViewportIdx - bufferRowCount, 0);\n\n  for (rowIdx = firstBufferIdx; rowIdx < firstViewportIdx; rowIdx++) {\n    (0, _updateRowHeight[\"default\"])(state, rowIdx);\n  } // Loop to walk the trailing buffer\n\n\n  var endViewportIdx = Math.max(startIdx, endIdx) + 1;\n  var endBufferIdx = Math.min(endViewportIdx + bufferRowCount, rowsCount);\n\n  for (rowIdx = endViewportIdx; rowIdx < endBufferIdx; rowIdx++) {\n    (0, _updateRowHeight[\"default\"])(state, rowIdx);\n  }\n\n  var _scrollbarsVisibleSel = (0, _scrollbarsVisible[\"default\"])(state),\n      availableHeight = _scrollbarsVisibleSel.availableHeight;\n\n  if (lastIndex !== undefined || forceScrollToLastRow) {\n    // Calculate offset needed to position last row at bottom of viewport\n    // This should be negative and represent how far the first row needs to be offscreen\n    // NOTE (jordan): The first offset should always be 0 when lastIndex is defined\n    // since we don't currently support scrolling the last row into view with an offset.\n    firstOffset = firstOffset + Math.min(availableHeight - totalHeight, 0); // Handle a case where the offset puts the first row fully offscreen\n    // This can happen if availableHeight & maxAvailableHeight are different\n\n    var storedHeights = state.storedHeights;\n\n    if (-1 * firstOffset >= storedHeights[firstViewportIdx]) {\n      firstViewportIdx += 1;\n      firstOffset += storedHeights[firstViewportIdx];\n    }\n  }\n\n  return {\n    endBufferIdx: endBufferIdx,\n    endViewportIdx: endViewportIdx,\n    firstBufferIdx: firstBufferIdx,\n    firstOffset: firstOffset,\n    firstViewportIdx: firstViewportIdx\n  };\n}\n/**\n * Walk the rows to render and compute the height offsets and\n * positions in the row buffer.\n *\n * NOTE (jordan) This alters state so it shouldn't be called\n * without state having been cloned first.\n *\n * @param {!Object} state\n * @param {{\n *   endBufferIdx: number,\n *   endViewportIdx: number,\n *   firstBufferIdx: number,\n *   firstViewportIdx: number,\n * }} rowRange\n * @param {boolean} viewportOnly\n * @private\n */\n\n\nfunction computeRenderedRowOffsets(state, rowRange, viewportOnly) {\n  var rowBufferSet = state.rowBufferSet,\n      rowOffsetIntervalTree = state.rowOffsetIntervalTree,\n      storedHeights = state.storedHeights;\n  var endBufferIdx = rowRange.endBufferIdx,\n      endViewportIdx = rowRange.endViewportIdx,\n      firstBufferIdx = rowRange.firstBufferIdx,\n      firstViewportIdx = rowRange.firstViewportIdx;\n  var renderedRowsCount = endBufferIdx - firstBufferIdx;\n\n  if (renderedRowsCount === 0) {\n    state.rowOffsets = {};\n    state.rows = [];\n    return;\n  }\n\n  var startIdx = viewportOnly ? firstViewportIdx : firstBufferIdx;\n  var endIdx = viewportOnly ? endViewportIdx : endBufferIdx; // output for this function\n\n  var rows = []; // state.rows\n\n  var rowOffsets = {}; // state.rowOffsets\n  // incremental way for calculating rowOffset\n\n  var runningOffset = rowOffsetIntervalTree.sumUntil(startIdx); // compute row index and offsets for every rows inside the buffer\n\n  for (var rowIdx = startIdx; rowIdx < endIdx; rowIdx++) {\n    // Update the offset for rendering the row\n    rowOffsets[rowIdx] = runningOffset;\n    runningOffset += storedHeights[rowIdx]; // Get position for the viewport row\n\n    var rowPosition = addRowToBuffer(rowIdx, rowBufferSet, startIdx, endIdx, renderedRowsCount);\n    rows[rowPosition] = rowIdx;\n  } // now we modify the state with the newly calculated rows and offsets\n\n\n  state.rows = rows;\n  state.rowOffsets = rowOffsets;\n}\n/**\n * Add the row to the buffer set if it doesn't exist.\n * If addition isn't possible due to max buffer size, it'll replace an existing element outside the given range.\n *\n * @param {!number} rowIdx\n * @param {!number} rowBufferSet\n * @param {!number} startRange\n * @param {!number} endRange\n * @param {!number} maxBufferSize\n *\n * @return {?number} the position of the row after being added to the buffer set\n * @private\n */\n\n\nfunction addRowToBuffer(rowIdx, rowBufferSet, startRange, endRange, maxBufferSize) {\n  // Check if row already has a position in the buffer\n  var rowPosition = rowBufferSet.getValuePosition(rowIdx); // Request a position in the buffer through eviction of another row\n\n  if (rowPosition === null && rowBufferSet.getSize() >= maxBufferSize) {\n    rowPosition = rowBufferSet.replaceFurthestValuePosition(startRange, endRange - 1, // replaceFurthestValuePosition uses closed interval from startRange to endRange\n    rowIdx);\n  }\n\n  if (rowPosition === null) {\n    rowPosition = rowBufferSet.getNewPositionForValue(rowIdx);\n  }\n\n  return rowPosition;\n}"]},"metadata":{},"sourceType":"script"}