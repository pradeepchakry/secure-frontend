{"ast":null,"code":"/**\n * Copyright Schrodinger, LLC\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * This is utility that handles touch events and calls provided touch\n * callback with correct frame rate.\n * Deceleration logic based on http://ariya.ofilabs.com/2013/11/javascript-kinetic-scrolling-part-2.html\n *\n * @providesModule ReactTouchHandler\n * @typechecks\n */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _emptyFunction = _interopRequireDefault(require('./emptyFunction'));\n\nvar _requestAnimationFramePolyfill = _interopRequireDefault(require('./requestAnimationFramePolyfill'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nvar MOVE_AMPLITUDE = 1.6;\nvar DECELERATION_AMPLITUDE = 1.6;\nvar DECELERATION_FACTOR = 325;\nvar TRACKER_TIMEOUT = 100;\n\nvar ReactTouchHandler = /*#__PURE__*/function () {\n  /**\n   * onTouchScroll is the callback that will be called with right frame rate if\n   * any touch events happened\n   * onTouchScroll should is to be called with two arguments: deltaX and deltaY in\n   * this order\n   */\n  function ReactTouchHandler(\n  /*function*/\n  onTouchScroll,\n  /*boolean|function*/\n  handleScrollX,\n  /*boolean|function*/\n  handleScrollY,\n  /*?boolean*/\n  preventDefault,\n  /*?boolean*/\n  stopPropagation) {\n    _classCallCheck(this, ReactTouchHandler); // The animation frame id for the drag scroll\n\n\n    this._dragAnimationId = null; // The interval id for tracking the drag velocity\n\n    this._trackerId = null; // Used to track the drag scroll delta while waiting for an animation frame\n\n    this._deltaX = 0;\n    this._deltaY = 0; // The last touch we processed while dragging.  Used to compute the delta and velocity above\n\n    this._lastTouchX = 0;\n    this._lastTouchY = 0; // Used to track a moving average of the scroll velocity while dragging\n\n    this._velocityX = 0;\n    this._velocityY = 0; // An accummulated drag scroll delta used to calculate velocity\n\n    this._accumulatedDeltaX = 0;\n    this._accumulatedDeltaY = 0; // Timestamp from the last interval frame we used to track velocity\n\n    this._lastFrameTimestamp = Date.now(); // Timestamp from the last animation frame we used to autoscroll after drag stop\n\n    this._autoScrollTimestamp = Date.now();\n\n    if (typeof handleScrollX !== 'function') {\n      handleScrollX = handleScrollX ? _emptyFunction[\"default\"].thatReturnsTrue : _emptyFunction[\"default\"].thatReturnsFalse;\n    }\n\n    if (typeof handleScrollY !== 'function') {\n      handleScrollY = handleScrollY ? _emptyFunction[\"default\"].thatReturnsTrue : _emptyFunction[\"default\"].thatReturnsFalse;\n    }\n\n    this._handleScrollX = handleScrollX;\n    this._handleScrollY = handleScrollY;\n    this._preventDefault = preventDefault;\n    this._stopPropagation = stopPropagation;\n    this._onTouchScrollCallback = onTouchScroll;\n    this._didTouchMove = this._didTouchMove.bind(this);\n    this._track = this._track.bind(this);\n    this._autoScroll = this._autoScroll.bind(this);\n    this._startAutoScroll = this._startAutoScroll.bind(this);\n    this.onTouchStart = this.onTouchStart.bind(this);\n    this.onTouchEnd = this.onTouchEnd.bind(this);\n    this.onTouchMove = this.onTouchMove.bind(this);\n    this.onTouchCancel = this.onTouchCancel.bind(this);\n  }\n\n  _createClass(ReactTouchHandler, [{\n    key: \"onTouchStart\",\n    value: function onTouchStart(\n    /*object*/\n    event) {\n      if (this._preventDefault) {\n        event.preventDefault();\n      } // Start tracking drag delta for scrolling\n\n\n      this._lastTouchX = event.touches[0].pageX;\n      this._lastTouchY = event.touches[0].pageY; // Reset our velocity and intermediate data used to compute velocity\n\n      this._velocityX = 0;\n      this._velocityY = 0;\n      this._accumulatedDeltaX = 0;\n      this._accumulatedDeltaY = 0;\n      this._lastFrameTimestamp = Date.now(); // Setup interval for tracking velocity\n\n      clearInterval(this._trackerId);\n      this._trackerId = setInterval(this._track, TRACKER_TIMEOUT);\n\n      if (this._stopPropagation) {\n        event.stopPropagation();\n      }\n    }\n  }, {\n    key: \"onTouchEnd\",\n    value: function onTouchEnd(\n    /*object*/\n    event) {\n      if (this._preventDefault) {\n        event.preventDefault();\n      } // Stop tracking velocity\n\n\n      clearInterval(this._trackerId);\n      this._trackerId = null; // Initialize decelerating autoscroll on drag stop\n\n      (0, _requestAnimationFramePolyfill[\"default\"])(this._startAutoScroll);\n\n      if (this._stopPropagation) {\n        event.stopPropagation();\n      }\n    }\n  }, {\n    key: \"onTouchCancel\",\n    value: function onTouchCancel(\n    /*object*/\n    event) {\n      // Stop tracking velocity\n      clearInterval(this._trackerId);\n      this._trackerId = null;\n\n      if (this._stopPropagation) {\n        event.stopPropagation();\n      }\n    }\n  }, {\n    key: \"onTouchMove\",\n    value: function onTouchMove(\n    /*object*/\n    event) {\n      if (this._preventDefault) {\n        event.preventDefault();\n      }\n\n      var moveX = event.touches[0].pageX;\n      var moveY = event.touches[0].pageY; // Compute delta scrolled since last drag\n      // Mobile, scrolling is inverted\n\n      this._deltaX = MOVE_AMPLITUDE * (this._lastTouchX - moveX);\n      this._deltaY = MOVE_AMPLITUDE * (this._lastTouchY - moveY);\n\n      var handleScrollX = this._handleScrollX(this._deltaX, this._deltaY);\n\n      var handleScrollY = this._handleScrollY(this._deltaY, this._deltaX);\n\n      if (!handleScrollX && !handleScrollY) {\n        return;\n      } // If we can handle scroll update last touch for computing delta\n\n\n      if (handleScrollX) {\n        this._lastTouchX = moveX;\n      } else {\n        this._deltaX = 0;\n      }\n\n      if (handleScrollY) {\n        this._lastTouchY = moveY;\n      } else {\n        this._deltaY = 0;\n      } // The event will result in a scroll to the table, so there's no need to also let the parent containers scroll\n\n\n      if (!event.defaultPrevented) {\n        event.preventDefault();\n      } // Ensure minimum delta magnitude is met to avoid jitter\n\n\n      var changed = false;\n\n      if (Math.abs(this._deltaX) > 2 || Math.abs(this._deltaY) > 2) {\n        if (this._stopPropagation) {\n          event.stopPropagation();\n        }\n\n        changed = true;\n      } // Request animation frame to trigger scroll of computed delta\n\n\n      if (changed === true && this._dragAnimationId === null) {\n        this._dragAnimationId = (0, _requestAnimationFramePolyfill[\"default\"])(this._didTouchMove);\n      }\n    }\n    /**\n     * Fire scroll callback based on computed drag delta.\n     * Also track accummulated delta so we can calculate velocity\n     */\n\n  }, {\n    key: \"_didTouchMove\",\n    value: function _didTouchMove() {\n      this._dragAnimationId = null;\n\n      this._onTouchScrollCallback(this._deltaX, this._deltaY);\n\n      this._accumulatedDeltaX += this._deltaX;\n      this._accumulatedDeltaY += this._deltaY;\n      this._deltaX = 0;\n      this._deltaY = 0;\n    }\n    /**\n     * Compute velocity based on a weighted average of drag over last 100 ms and\n     * previous velocity.  Combining into a moving average results in a smoother scroll.\n     */\n\n  }, {\n    key: \"_track\",\n    value: function _track() {\n      var now = Date.now();\n      var elapsed = now - this._lastFrameTimestamp;\n      var oldVelocityX = this._velocityX;\n      var oldVelocityY = this._velocityY; // We compute velocity using a weighted average of the current velocity and the previous velocity\n      // If the previous velocity is 0, put the full weight on the last 100 ms\n\n      var weight = 0.8;\n\n      if (elapsed < TRACKER_TIMEOUT) {\n        weight *= elapsed / TRACKER_TIMEOUT;\n      }\n\n      if (oldVelocityX === 0 && oldVelocityY === 0) {\n        weight = 1;\n      } // Formula for computing weighted average of velocity\n\n\n      this._velocityX = weight * (TRACKER_TIMEOUT * this._accumulatedDeltaX / (1 + elapsed));\n\n      if (weight < 1) {\n        this._velocityX += (1 - weight) * oldVelocityX;\n      }\n\n      this._velocityY = weight * (TRACKER_TIMEOUT * this._accumulatedDeltaY / (1 + elapsed));\n\n      if (weight < 1) {\n        this._velocityY += (1 - weight) * oldVelocityY;\n      }\n\n      this._accumulatedDeltaX = 0;\n      this._accumulatedDeltaY = 0;\n      this._lastFrameTimestamp = now;\n    }\n    /**\n     * To kick off deceleration / momentum scrolling,\n     * handle any scrolling from a drag which was waiting for an animation frame\n     * Then update our velocity\n     * Finally start the momentum scrolling handler (autoScroll)\n     */\n\n  }, {\n    key: \"_startAutoScroll\",\n    value: function _startAutoScroll() {\n      this._autoScrollTimestamp = Date.now();\n\n      if (this._deltaX > 0 || this.deltaY > 0) {\n        this._didTouchMove();\n      }\n\n      this._track();\n\n      this._autoScroll();\n    }\n    /**\n     * Compute a scroll delta with an exponential decay based on time elapsed since drag was released.\n     * This is called recursively on animation frames until the delta is below a threshold (5 pixels)\n     */\n\n  }, {\n    key: \"_autoScroll\",\n    value: function _autoScroll() {\n      var elapsed = Date.now() - this._autoScrollTimestamp;\n\n      var factor = DECELERATION_AMPLITUDE * Math.exp(-elapsed / DECELERATION_FACTOR);\n      var deltaX = factor * this._velocityX;\n      var deltaY = factor * this._velocityY;\n\n      if (Math.abs(deltaX) <= 5 || !this._handleScrollX(deltaX, deltaY)) {\n        deltaX = 0;\n      }\n\n      if (Math.abs(deltaY) <= 5 || !this._handleScrollY(deltaY, deltaX)) {\n        deltaY = 0;\n      }\n\n      if (deltaX !== 0 || deltaY !== 0) {\n        this._onTouchScrollCallback(deltaX, deltaY);\n\n        (0, _requestAnimationFramePolyfill[\"default\"])(this._autoScroll);\n      }\n    }\n  }]);\n\n  return ReactTouchHandler;\n}();\n\nvar _default = ReactTouchHandler;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["/home/discovery/Documents/secure-frontend/node_modules/fixed-data-table-2/internal/ReactTouchHandler.js"],"names":["Object","defineProperty","exports","value","_emptyFunction","_interopRequireDefault","require","_requestAnimationFramePolyfill","obj","__esModule","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","_createClass","protoProps","staticProps","prototype","MOVE_AMPLITUDE","DECELERATION_AMPLITUDE","DECELERATION_FACTOR","TRACKER_TIMEOUT","ReactTouchHandler","onTouchScroll","handleScrollX","handleScrollY","preventDefault","stopPropagation","_dragAnimationId","_trackerId","_deltaX","_deltaY","_lastTouchX","_lastTouchY","_velocityX","_velocityY","_accumulatedDeltaX","_accumulatedDeltaY","_lastFrameTimestamp","Date","now","_autoScrollTimestamp","thatReturnsTrue","thatReturnsFalse","_handleScrollX","_handleScrollY","_preventDefault","_stopPropagation","_onTouchScrollCallback","_didTouchMove","bind","_track","_autoScroll","_startAutoScroll","onTouchStart","onTouchEnd","onTouchMove","onTouchCancel","event","touches","pageX","pageY","clearInterval","setInterval","moveX","moveY","defaultPrevented","changed","Math","abs","elapsed","oldVelocityX","oldVelocityY","weight","deltaY","factor","exp","deltaX","_default"],"mappings":"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","sourcesContent":["/**\n * Copyright Schrodinger, LLC\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * This is utility that handles touch events and calls provided touch\n * callback with correct frame rate.\n * Deceleration logic based on http://ariya.ofilabs.com/2013/11/javascript-kinetic-scrolling-part-2.html\n *\n * @providesModule ReactTouchHandler\n * @typechecks\n */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _emptyFunction = _interopRequireDefault(require('./emptyFunction'));\n\nvar _requestAnimationFramePolyfill = _interopRequireDefault(require('./requestAnimationFramePolyfill'));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar MOVE_AMPLITUDE = 1.6;\nvar DECELERATION_AMPLITUDE = 1.6;\nvar DECELERATION_FACTOR = 325;\nvar TRACKER_TIMEOUT = 100;\n\nvar ReactTouchHandler = /*#__PURE__*/function () {\n  /**\n   * onTouchScroll is the callback that will be called with right frame rate if\n   * any touch events happened\n   * onTouchScroll should is to be called with two arguments: deltaX and deltaY in\n   * this order\n   */\n  function ReactTouchHandler(\n  /*function*/\n  onTouchScroll,\n  /*boolean|function*/\n  handleScrollX,\n  /*boolean|function*/\n  handleScrollY,\n  /*?boolean*/\n  preventDefault,\n  /*?boolean*/\n  stopPropagation) {\n    _classCallCheck(this, ReactTouchHandler);\n\n    // The animation frame id for the drag scroll\n    this._dragAnimationId = null; // The interval id for tracking the drag velocity\n\n    this._trackerId = null; // Used to track the drag scroll delta while waiting for an animation frame\n\n    this._deltaX = 0;\n    this._deltaY = 0; // The last touch we processed while dragging.  Used to compute the delta and velocity above\n\n    this._lastTouchX = 0;\n    this._lastTouchY = 0; // Used to track a moving average of the scroll velocity while dragging\n\n    this._velocityX = 0;\n    this._velocityY = 0; // An accummulated drag scroll delta used to calculate velocity\n\n    this._accumulatedDeltaX = 0;\n    this._accumulatedDeltaY = 0; // Timestamp from the last interval frame we used to track velocity\n\n    this._lastFrameTimestamp = Date.now(); // Timestamp from the last animation frame we used to autoscroll after drag stop\n\n    this._autoScrollTimestamp = Date.now();\n\n    if (typeof handleScrollX !== 'function') {\n      handleScrollX = handleScrollX ? _emptyFunction[\"default\"].thatReturnsTrue : _emptyFunction[\"default\"].thatReturnsFalse;\n    }\n\n    if (typeof handleScrollY !== 'function') {\n      handleScrollY = handleScrollY ? _emptyFunction[\"default\"].thatReturnsTrue : _emptyFunction[\"default\"].thatReturnsFalse;\n    }\n\n    this._handleScrollX = handleScrollX;\n    this._handleScrollY = handleScrollY;\n    this._preventDefault = preventDefault;\n    this._stopPropagation = stopPropagation;\n    this._onTouchScrollCallback = onTouchScroll;\n    this._didTouchMove = this._didTouchMove.bind(this);\n    this._track = this._track.bind(this);\n    this._autoScroll = this._autoScroll.bind(this);\n    this._startAutoScroll = this._startAutoScroll.bind(this);\n    this.onTouchStart = this.onTouchStart.bind(this);\n    this.onTouchEnd = this.onTouchEnd.bind(this);\n    this.onTouchMove = this.onTouchMove.bind(this);\n    this.onTouchCancel = this.onTouchCancel.bind(this);\n  }\n\n  _createClass(ReactTouchHandler, [{\n    key: \"onTouchStart\",\n    value: function onTouchStart(\n    /*object*/\n    event) {\n      if (this._preventDefault) {\n        event.preventDefault();\n      } // Start tracking drag delta for scrolling\n\n\n      this._lastTouchX = event.touches[0].pageX;\n      this._lastTouchY = event.touches[0].pageY; // Reset our velocity and intermediate data used to compute velocity\n\n      this._velocityX = 0;\n      this._velocityY = 0;\n      this._accumulatedDeltaX = 0;\n      this._accumulatedDeltaY = 0;\n      this._lastFrameTimestamp = Date.now(); // Setup interval for tracking velocity\n\n      clearInterval(this._trackerId);\n      this._trackerId = setInterval(this._track, TRACKER_TIMEOUT);\n\n      if (this._stopPropagation) {\n        event.stopPropagation();\n      }\n    }\n  }, {\n    key: \"onTouchEnd\",\n    value: function onTouchEnd(\n    /*object*/\n    event) {\n      if (this._preventDefault) {\n        event.preventDefault();\n      } // Stop tracking velocity\n\n\n      clearInterval(this._trackerId);\n      this._trackerId = null; // Initialize decelerating autoscroll on drag stop\n\n      (0, _requestAnimationFramePolyfill[\"default\"])(this._startAutoScroll);\n\n      if (this._stopPropagation) {\n        event.stopPropagation();\n      }\n    }\n  }, {\n    key: \"onTouchCancel\",\n    value: function onTouchCancel(\n    /*object*/\n    event) {\n      // Stop tracking velocity\n      clearInterval(this._trackerId);\n      this._trackerId = null;\n\n      if (this._stopPropagation) {\n        event.stopPropagation();\n      }\n    }\n  }, {\n    key: \"onTouchMove\",\n    value: function onTouchMove(\n    /*object*/\n    event) {\n      if (this._preventDefault) {\n        event.preventDefault();\n      }\n\n      var moveX = event.touches[0].pageX;\n      var moveY = event.touches[0].pageY; // Compute delta scrolled since last drag\n      // Mobile, scrolling is inverted\n\n      this._deltaX = MOVE_AMPLITUDE * (this._lastTouchX - moveX);\n      this._deltaY = MOVE_AMPLITUDE * (this._lastTouchY - moveY);\n\n      var handleScrollX = this._handleScrollX(this._deltaX, this._deltaY);\n\n      var handleScrollY = this._handleScrollY(this._deltaY, this._deltaX);\n\n      if (!handleScrollX && !handleScrollY) {\n        return;\n      } // If we can handle scroll update last touch for computing delta\n\n\n      if (handleScrollX) {\n        this._lastTouchX = moveX;\n      } else {\n        this._deltaX = 0;\n      }\n\n      if (handleScrollY) {\n        this._lastTouchY = moveY;\n      } else {\n        this._deltaY = 0;\n      } // The event will result in a scroll to the table, so there's no need to also let the parent containers scroll\n\n\n      if (!event.defaultPrevented) {\n        event.preventDefault();\n      } // Ensure minimum delta magnitude is met to avoid jitter\n\n\n      var changed = false;\n\n      if (Math.abs(this._deltaX) > 2 || Math.abs(this._deltaY) > 2) {\n        if (this._stopPropagation) {\n          event.stopPropagation();\n        }\n\n        changed = true;\n      } // Request animation frame to trigger scroll of computed delta\n\n\n      if (changed === true && this._dragAnimationId === null) {\n        this._dragAnimationId = (0, _requestAnimationFramePolyfill[\"default\"])(this._didTouchMove);\n      }\n    }\n    /**\n     * Fire scroll callback based on computed drag delta.\n     * Also track accummulated delta so we can calculate velocity\n     */\n\n  }, {\n    key: \"_didTouchMove\",\n    value: function _didTouchMove() {\n      this._dragAnimationId = null;\n\n      this._onTouchScrollCallback(this._deltaX, this._deltaY);\n\n      this._accumulatedDeltaX += this._deltaX;\n      this._accumulatedDeltaY += this._deltaY;\n      this._deltaX = 0;\n      this._deltaY = 0;\n    }\n    /**\n     * Compute velocity based on a weighted average of drag over last 100 ms and\n     * previous velocity.  Combining into a moving average results in a smoother scroll.\n     */\n\n  }, {\n    key: \"_track\",\n    value: function _track() {\n      var now = Date.now();\n      var elapsed = now - this._lastFrameTimestamp;\n      var oldVelocityX = this._velocityX;\n      var oldVelocityY = this._velocityY; // We compute velocity using a weighted average of the current velocity and the previous velocity\n      // If the previous velocity is 0, put the full weight on the last 100 ms\n\n      var weight = 0.8;\n\n      if (elapsed < TRACKER_TIMEOUT) {\n        weight *= elapsed / TRACKER_TIMEOUT;\n      }\n\n      if (oldVelocityX === 0 && oldVelocityY === 0) {\n        weight = 1;\n      } // Formula for computing weighted average of velocity\n\n\n      this._velocityX = weight * (TRACKER_TIMEOUT * this._accumulatedDeltaX / (1 + elapsed));\n\n      if (weight < 1) {\n        this._velocityX += (1 - weight) * oldVelocityX;\n      }\n\n      this._velocityY = weight * (TRACKER_TIMEOUT * this._accumulatedDeltaY / (1 + elapsed));\n\n      if (weight < 1) {\n        this._velocityY += (1 - weight) * oldVelocityY;\n      }\n\n      this._accumulatedDeltaX = 0;\n      this._accumulatedDeltaY = 0;\n      this._lastFrameTimestamp = now;\n    }\n    /**\n     * To kick off deceleration / momentum scrolling,\n     * handle any scrolling from a drag which was waiting for an animation frame\n     * Then update our velocity\n     * Finally start the momentum scrolling handler (autoScroll)\n     */\n\n  }, {\n    key: \"_startAutoScroll\",\n    value: function _startAutoScroll() {\n      this._autoScrollTimestamp = Date.now();\n\n      if (this._deltaX > 0 || this.deltaY > 0) {\n        this._didTouchMove();\n      }\n\n      this._track();\n\n      this._autoScroll();\n    }\n    /**\n     * Compute a scroll delta with an exponential decay based on time elapsed since drag was released.\n     * This is called recursively on animation frames until the delta is below a threshold (5 pixels)\n     */\n\n  }, {\n    key: \"_autoScroll\",\n    value: function _autoScroll() {\n      var elapsed = Date.now() - this._autoScrollTimestamp;\n\n      var factor = DECELERATION_AMPLITUDE * Math.exp(-elapsed / DECELERATION_FACTOR);\n      var deltaX = factor * this._velocityX;\n      var deltaY = factor * this._velocityY;\n\n      if (Math.abs(deltaX) <= 5 || !this._handleScrollX(deltaX, deltaY)) {\n        deltaX = 0;\n      }\n\n      if (Math.abs(deltaY) <= 5 || !this._handleScrollY(deltaY, deltaX)) {\n        deltaY = 0;\n      }\n\n      if (deltaX !== 0 || deltaY !== 0) {\n        this._onTouchScrollCallback(deltaX, deltaY);\n\n        (0, _requestAnimationFramePolyfill[\"default\"])(this._autoScroll);\n      }\n    }\n  }]);\n\n  return ReactTouchHandler;\n}();\n\nvar _default = ReactTouchHandler;\nexports[\"default\"] = _default;"]},"metadata":{},"sourceType":"script"}